# importing necesarry ibraries

import PIL
from PIL import Image, ImageDraw
import pathlib

import math
import numpy as np

import matplotlib.pyplot as plt


# create an image object for the given world map,to be used only by the get_lidar_reading function,not in LidarScanner
image = Image.open(pathlib.Path('worldmap.jpg'))

# convert the image to binary
image = image.convert('1')

# resize the image to (400,400)
image.thumbnail((400, 400))
image_size = min(image.size)


def get_lidar_reading(centerX, centerY, no_of_rays=360):
    '''This mimics the lidar sensor'''

    lidar_reading = []

    if image.getpixel((centerX, centerY)) == 0:
        print("invalid")  # point inside wall
    else:
        for i in range(0, 360, int(360/no_of_rays)):
            r = 0

            currentX = round(centerX + r*math.cos(i*math.pi/180))
            currentY = round(centerY + r*math.sin(i*math.pi/180))

            while ((currentX < image_size and currentX >= 0) and (currentY < image_size and currentY >= 0) and (image.getpixel((currentX, currentY)) != 0)):
                currentX = round(centerX + r*math.cos(i*math.pi/180))
                currentY = round(centerY + r*math.sin(i*math.pi/180))
                r += 1

            lidar_reading.append((i, r))

        return lidar_reading


'''
Workflow-
1.Consider only some points(number is determined by the quality of map seeked for)
2.If the point is already detected,remove it from schrodingers points
3.If the point is known to be inside a wall fs, remove it from schrodingers points
4.The next scan must be on a detected point.
5.To decide scan,make a hill at every scanned point and then find the place of lowest height.
6.. Repeat until we dont have any scrodingers point left
'''


class LidarScanner:

    def __init__(self, initialX, initialY, map_size, quality1=20, quality2=50):
        '''Initializes the parameters of scanner model'''
        # current position of scanner
        self.position = [initialX, initialY]

        # the map generated by lidar
        self.map = map = PIL.Image.new(mode="1", size=map_size)

        self.map_quality = quality1
        self.schr_negligence = quality2

        # points which are uncertain,can be either i9nside wall and free points
        self.schr_points = []

        # points which are detected by the lidar to be free
        self.detected_points = [(initialX, initialY)]

        # points where the lidar has made a scan
        self.scanned_points = []
        self.walls = []

        for (x, y), point in np.ndenumerate(np.zeros_like(map)):
            if x % quality1 == 0 and y % quality1 == 0:
                self.schr_points.append((x, y))

        self.prev_schr_count = len(self.schr_points)

    def run_scanner(self):
        '''Runs scans'''
        firstRun = True

        # while the map quality is not-so-good
        while True:
            self.prev_schr_count = len(self.schr_points)
            # remove the points scanned last time from scrodinger's points list
            for point in self.schr_points:
                self.is_detected(point)
            # get next point to be scanned
            scan_point = self.get_next_scan()

            # move to the next scanned point
            self.position = scan_point
            print(self.position)

            # make a scan at the current position
            lidar_reading = get_lidar_reading(
                self.position[0], self.position[1])

            # plot the lidar reading on scanner's map
            self.plot_reading_on__map(lidar_reading)

            # add the point to list of scanned point
            self.scanned_points.append(scan_point)

            # the current loop breaking condition is that if the no. of schr_points does'nt change much,
            # the map is considered c0ompleted. However i plan to somehow dtect what all points are inside wall
            # and then break looop when there's no schr_point

            schr_fall = self.prev_schr_count-len(self.schr_points)
            if schr_fall < self.schr_negligence and not firstRun:
                break

            firstRun = False

            # display the generated map
            self.display_map()

            # TODO:find a better loop exit point

    def is_detected(self, point):
        '''If the point is detected by the lidar,remove it'''

        # All the detected points are marked with 255
        if self.map.getpixel(point) != 0:

            # remove the point from schrodinger's points
            self.schr_points.remove(point)

            # add the point to detected points
            self.detected_points.append(point)

            # the point was detected, so return true
            return True
        else:
            # the point was not detected, so return false
            return False

    def get_next_scan(self):
        '''decides the next point to be scanned ny ensuring it to be far from every point scanned so far'''

        # key=A point from detected point
        # value=it's sum of distances of all the scanned point from the key point,if it is at a given distance from each of the scanned point
        dist = {}

        # The scan has to be from the detected points only,we can't scan a schrodinger point as it may be inside wall
        for point in self.detected_points:

            # distances of given point from all scanned point
            d = []

            # avoid scanning a point twice
            if point not in self.scanned_points:
                min_d=np.inf
                for pt in self.scanned_points:
                    distance = (point[0]-pt[0])**2+(point[1]-pt[1])**2
                    if distance <min_d:
                        min_d=distance
                    
                dist[point] = min_d

        # return the point with maximum distance from the scanned points
        v = list(dist.values())
        k = list(dist.keys())

        return(k[v.index(max(v))])

    def plot_reading_on__map(self, lidar_reading):
        '''This plots the collected lidar data on map'''

        centerX = self.position[0]
        centerY = self.position[1]

        for i, reading in enumerate(lidar_reading):

            try:
                '''As the angle given by lidar is integral,
                if we try to map all the points where lidar's light could pass,
                we see that the generated map doesnt show the points between two light rays.
                So here I have collected two consecutive points which lidar has detected,which are
                expected to be at a very close distance,and then collect all the points inside the
                triangle formed by these points-
                1.point where the sensor is
                2 and 3.The close consecutive points
                Credits-MATH calculus course :)
                '''
                i0 = reading[0]
                r0 = reading[1]

                i1 = lidar_reading[i+1][0]
                r1 = lidar_reading[i+1][1]

                x0 = int(r0*math.cos(i0*math.pi/180)+centerX)
                y0 = int((r0*math.sin(i0*math.pi/180)+centerY))

                x1 = int(r1*math.cos(i1*math.pi/180)+centerX)
                y1 = int((r1*math.sin(i1*math.pi/180)+centerY))

                self.walls.append((x0, y0))

                draw = ImageDraw.Draw(self.map)
                draw.polygon([(centerX, centerY), (x0, y0),
                              (x1, y1)], fill=255, outline=255)

            except:
                # to avoid encountering error at the edges
                continue

    def display_map(self):
        '''Displays the generated map'''

        plt.imshow(self.map, cmap='gray')
        plt.show()


ls = LidarScanner(initialX=399, initialY=0,
                  map_size=image.size, quality1=20, quality2=50)
ls.run_scanner()
ls.display_map()
